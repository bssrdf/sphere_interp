MODULE SPH_ANALYSIS
    USE VAND_SPH
    IMPLICIT NONE

CONTAINS

SUBROUTINE toab(coef, mean, a, b)
    ! This subroutine takes in a coefficient array
    ! and a function mean and translates it into
    ! coefficient matrices a,b which can be used in spherepack
    !
    ! inputs:
    !   coef -- real, dimension(0:(l+1)**2) --
    !       coefficient array for spherical harmonics
    !
    ! outputs:
    !   a -- allocatable array, can be fed into spherepack
    !   b -- allocatable array, can be fed into spherepack

    ! inputs
    real, dimension(0:),intent(in) :: coef
    real, intent(in) :: mean

    ! outputs
    real, allocatable, dimension(:,:), intent(out) :: a
    real, allocatable, dimension(:,:), intent(out) :: b

    ! helper variables
    integer :: maxl, l, m
    
    ! Since coef is a linear array ranging from 0:(maxl+1)**2
    maxl = int(sqrt(size(coef)-1.0) - 1)

    allocate( a(0:maxl,0:maxl) )
    allocate( b(0:maxl,0:maxl) )

    do l=0,maxl
    do m=0,l
        a(m,l) = coef(ml2sIdx(m,l))
        if (m > 0) then
            b(m,l) = coef(ml2sIdx(-1*m,l))
        else
            b(m,l) = 0
        endif
    end do
    end do
END SUBROUTINE toab

SUBROUTINE scalef(f, mean, scalefact)
    ! Scales f to values of (-1,1)
    !
    ! inputs:
    !   f -- real, dimension(1:nloc) --
    !     input array
    !
    ! outputs:
    !   f -- real, dimension(1:nloc) --
    !     rescaled input array
    !   mean -- real --
    !     mean of input f
    !   scalefact -- real --
    !     scale factor for f
    !
    ! input f can be formed by taking
    ! scalefact*(f + mean)
    
    !inputs
    real, dimension(:), intent(inout) :: f

    !outputs
    real, intent(out) :: mean
    real, intent(out) :: scalefact

    !temporary variables
    integer :: nloc

    ! rescale and save values
    nloc = size(f)
    mean = sum(f)
    mean = mean/float(nloc)
    
    ! TODO: work out if scaling this is a bad idea...
    !scalefact = maxval(abs(f))
    ! f = f/scalefact

END SUBROUTINE scalef

SUBROUTINE analysis(M_T, f, coef_out, tol_in, alpha)
    ! Calculates the spherical analysis of f
    ! This is a spherical harmonic fit to the difference
    ! from the mean, not an interpolation of the function itself
    !
    ! inputs:
    !   M_T -- real, dimension(lmax**2,nlocs) --
    !       Vandermonde-like matrix for spherical harmonics.
    !       Generated by vand_sph module
    !   f   -- real, dimension(nlocs) --
    !       function values
    !
    ! outputs:
    !   coef_out -- real, dimension(lmax**2 + 1) --
    !       coefficients of spherical harmonics
    !
    ! optional inputs:
    !   tol_in -- real -- 1e-06 --
    !       tolerance for convergence.
    !       Defaults to 1e-6
    !   alpha  -- real -- 0.5 --
    !       value by which to scale smoothing factor if it is too large.
    !       Must be between 0 and 1, otherwise defaults to 0.5
    
    !inputs
    real, dimension(:,:), intent(in) :: M_T
    real, dimension(size(M_T,2)), intent(in) :: f
    real, optional, intent(in) :: tol_in
    real, optional, intent(in) :: alpha
    
    !outputs
    real, dimension(0:size(M_T,1)+1), intent(out) :: coef_out
    
    ! variables used throughout computation
    real :: tol, scale, fscale
    real :: lambda
    real :: delta_p, delta_n
    integer :: l, c
    real, dimension(size(M_T,1)) :: coef_p, coef_n
    real, dimension(size(M_T,1)) :: BinvMTf
    real, dimension(size(M_T,2), size(M_T,1) :: M
    
    ! rescale f
    call scalef(f, coef_out(0), fscale)
    
    ! extract optional inputs
    ! TODO: figure out a good default value for this
    tol = 1e-6
    if (present(tol_in)) tol = tol_in
    scale = 2
    if (present(alpha) .and. alpha .gt. 0 .and. alpha .lt. 1) scale = 1/alpha
    
    ! initialize values
    coef_p = 0.0
    M = TRANSPOSE(M_T)
    lambda = MATMUL(f,f)/MATMUL(MATMUL(M_T,f),MATMUL(M_T,f))
    ! update M_T to instead be B^{-1} M_T since we no longer need M_T in the calculation
    DO l = 1:size(M_T,1)**.5 !TODO: figure out the correct largest value of l
        c = ????
        M_T(c-l:c+l,:) = l*(l+1)*M_T(c-l:c+l,:)
    END DO
    
    BinvMTf = MATMUL(M_T,f)
    coef_n = 2*lambda*BinvMTf
    delta_n = MATMUL(coef_n - coef_p, coef_n - coef_p)
    
    ! loop through and update
    DO WHILE ( delta_n .ge. tol)
        delta_p = delta_n
        coef_p = coef_n
        coef_n = 2*lambda*( BinvMTf - MATMUL( M_T , MATMUL(M,coef_p) ) )
        delta_n = MATMUL(coef_n - coef_p, coef_n - coef_p)
        DO WHILE ( delta_n .ge. delta_p)
            lambda = lambda/scale
            coef_n = 2*lambda*( BinvMTf - MATMUL( M_T , MATMUL(M,coef_p) ) )
            delta_n = MATMUL(coef_n - coef_p, coef_n - coef_p)
        END DO
    END DO
    
    !TODO: check that this is indeed the correct way to correct scaling...
    coef_out(1:) = fscale*coef_n
    
END SUBROUTINE analysis

END MODULE SPH_ANALYSIS
